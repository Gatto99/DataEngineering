\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\title{Ingegneria dei dati: Homework 2}
\author{Davide Gattini}
\date{Ottobre 2022}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{prompt}{
    stringstyle=\color{OliveGreen},
    basicstyle=\itshape\ttfamily,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=c,                    
    keepspaces=true,                 
    showspaces=false,                
    showstringspaces=false,
    moredelim=**[is][\color{OliveGreen}]{@}{@},
}

\begin{document}

\maketitle

\section{Analyzers}
Per il campo \textbf{\textit{filename}} si è scelto l'uso di un \textit{StandardAnalyzer} così caratterizzato:
\begin{itemize}
	\item Tokenizer
	\begin{itemize}
		\item StandardTokenizer
	\end{itemize}
	\item Token filter
	\begin{itemize}
		\item LowerCaseFilter
	\end{itemize}
\end{itemize}

La scelta deriva dalla volontà di permettere all'utente la ricerca delle canzoni tramite il loro titolo, ignorando che quest'ultimo possa contenere lettere maiuscole e/o una punteggiature, infatti colui che ricerca i titoli delle canzoni si suppone lo faccia senza pensare a questi dettagli. 
\iffalse
e qualora non si facessero queste considerazioni, i documenti cui titoli hanno punteggiatura o maiuscole, non verranno trovati dal programma a meno che l'utente non sappia dove esse si trovano. 
\fi

Mentre per il campo \textbf{\textit{content}} viene applicato lo \textit{CustomAnalyzer}:
\begin{itemize}
	\item Tokenizer
	\begin{itemize}
		\item StandardTokenizer
	\end{itemize}
	\item Token filter
	\begin{itemize}
		\item LowerCaseFilter
		\item StopFilter (stop words = \{\textit{of}, \textit{an}, \textit{a}, \textit{the}, \textit{for}\})
        \item EnglishPossessiveFilter
	\end{itemize}
\end{itemize}

L'adozione di un analyzer di questo tipo per il lyrics delle canzoni nel corpus, permette di evitare l'indicizzazione di termini molto comuni che saranno ignorati in fase di ricerca poiché si punta ad offrire all'utente il maggior numero possibile di documenti, garantendo efficienza nell'indicizzazione. Inoltre non pensiamo alle maiuscole, né tanto meno ai vari delimitatori e alla punteggiatura per evitare che ne sia richiesta conoscenza a chi esegue la ricerca. Quindi ciò che è stato detto per il titolo, vale anche per il testo. Lo metto nel contenuto e non nella query perché si suppone vengano usate nella query qualora l utente si ricordasse tutto per bene.
L'ultima considerazione riguarda la presenza di un filtro per il genitivo sassone che viene filtrato poiché è stato considerato come un dettaglio da poter trascurare e quindi non indicizzare.

Infine per la \textbf{\textit{query}}, poiché si è usato il query parser, è stato necessario utilizzare un ulteriore analyzer e la scelta è ricaduta sempre su di un \textit{StandardAnalyzer}.
Da sottolineare che non sono state definite delle stop word, così da permettere all'utente di inserire una phrase query contenente questi termini che quindi vengono indicizzate, così considerate qualora si ricordasse il titolo della canzone di cui vuole leggere il testo. Si suppone infatti, che il titolo cercato sia più facile da ricordare, quindi è possibile che vengano inserite potenziali stop word da non ignorare. Mentre per il contenuto, grazie al relativo analyzer, queste, sebbene indicizzate dalla query, non troveranno una corrispondenza nel testo indicizzato di una canzone (se appartenenti all'insieme di stop word definito sopra), soddisfacendo l'obiettivo definito precedentemente, cioè quello di permettere il retrieval di più documenti possibili in questo caso.

\section{File indicizzati e tempo di indicizzazione}
I file che sono stati indicizzati sono stati recuperati tramite l'uso dell'API \href{https://lyricsgenius.readthedocs.io/en/master/}{\textit{lyricsGenius}}, la quale, tramite uno script python, ha permesso l'estrazione e il salvataggio dei testi delle 100 canzoni più popolari dei Coldplay. Di conseguenza, il nome di ogni file corrisponde al nome della canzone a cui sono stati eliminati i caratteri speciali ed il lyrics associato è stato invece salvato in formato testuale.
\begingroup
\setlength{\tabcolsep}{5pt} % Default value: 6pt
\renewcommand{\arraystretch}{1.5} % Default value: 1
\begin{center}
\begin{table}[h!]
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
    \multicolumn{10}{|c|}{Tempo d'indicizzazione per i-esima esecuzione}\\
    \hline
    1° & 2° & 3° & 4° & 5° & 6° & 7° & 8° & 9° & 10° \\
    \hline
        $49ms$ & $50ms$ & $47ms$ & $46ms$ & $43ms$ & $44ms$ & $41ms$ & $39ms$ & $42ms$ & $45ms$ \\
    \hline
    \end{tabular}
    \caption{In questa tabella sono stati riportati i tempi impiegati dal programma per indicizzare i documenti nel corpus: si ha una media di $\sim{357ms}$.}
\end{table}
\end{center}
\endgroup

\section{Query testate}
Di seguito saranno elencate le query testate, suddivise per il campo su cui sono state effettuate. Prima di farlo, è utile sottolineare che le query, lette da riga di comando, sono processate dal programma tramite il \textit{QueryParser} che permette così di comprendere quando l'utente chiede l'esecuzione di una \textit{PhraseQuery} o, più in generale, di fare il parsing della stringa in input permettendo l'utilizzo di alcuni simboli (e.g. \verb|+| e \verb|-|, vedi ~\ref{filenameFieldQuery}).
Si noti che qualora la query corrisponda ad una stringa vuota, verrà processata senza riportare documenti (questo comportamente è permesso dall'uso della funzione \textit{MatchNoDocsQuery()}).

\subsection{Campo: \textit{filename}} \label{filenameFieldQuery}

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @filename: "A Sky Full Of Stars"@
\end{lstlisting}
\end{tabular}    
\end{center}
Questa PhraseQuery, caratterizzata anche da lettere maiuscole, è stata utilizzata per testare che le maiuscole vengano correttamente ignorate, poiché sia per il filename che per il content, i vari termini sono stati indicizzati con tutte le lettere minuscole.

doc38:A Sky Full of Stars

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @filename: "a sky full of stars"@
\end{lstlisting}
\end{tabular}    
\end{center}
In questo caso si è testato, tramite una PhraseQuery con solo minuscole, che il risultato della query precedente fosse uguale alla query in questione.

doc38:A Sky Full of Stars

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @filename: -sky +full@
\end{lstlisting}
\end{tabular}    
\end{center}
La TermQuery corrente è caratterizzata da simboli posti come prefisso dei singoli termini e in questo caso la query, grazie al QueryParser, viene riconosciuta per eseguire una ricerca nel corpus dei file cui titolo presenta necessariamente "full", ma che non deve contenere "sky".

doc4:A Head Full of Dreams

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @filename: LOVE@
\end{lstlisting}
\end{tabular}    
\end{center}
Si è testata l'indipendenza dalle maiuscole anche quando viene passato un solo termine, quindi per verificare che i documenti trovati siano relativi a file cui nome contiene la stessa parola in qualsiasi formato.

doc26:True Love
doc37:Lovers in Japan   Reign of Love

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @filename: The Scie@
\end{lstlisting}
\end{tabular}    
\end{center}
Per verificare la correttezza del sistema di ranking e di ricerca, è stato controllato che, passato un termine troncato, vengano comunque trovati i file cui nome include parole "vicine" al termine cercato. Si noti che, non avendo ignorato parole comuni come "The", vengono anche riportati tanti altri documenti, ma grazie al ranking vengono valutati meno del file ricercato, cioè \textit{The Scientist.txt}

doc44:The Scientist (1.0745345)
doc30:The Hardest Part (0.9128916)
doc23:Hymn for the Weekend (0.7935219)
doc52:People of the Pride (0.7935219)
doc70:Champion of the World (0.7935219)
doc72:X Marks the Spot (0.7935219)
doc86:Us Against the World (0.7935219)
doc87:Swallowed in the Sea (0.7935219)
doc83:Hymn for the Weekend  Seeb Remix  (0.6290202)
doc61:Hymn for the Weekend  Alan Walker Remix  (0.569944)

\iffalse
    \begin{itemize}
    \item \textit{\textbf{filename: "A Sky Full Of Stars"}}. Questa PhraseQuery, caratterizzata anche da lettere maiuscole, è stata utilizzata per testare che le maiuscole vengano correttamente ignorate, poiché sia per il filename che per il content, i vari termini sono stati indicizzati con tutte le lettere minuscole.
    \item \textit{\textbf{filename: "a sky full of stars"}}. In questo caso si è testato, tramite una PhraseQuery con solo minuscole, che il risultato della query precedente fosse uguale alla query in questione.
    \item \textit{\textbf{filename: -sky +full}}. La TermQuery corrente è caratterizzata da simboli posti come prefisso dei singoli termini e in questo caso la query, grazie al QueryParser, viene riconosciuta per eseguire una ricerca nel corpus dei file cui titolo presenta necessariamente "full", ma che non deve contenere "sky".
    \item \textit{\textbf{filename: LOVE}}. Si è testata l'indipendenza dalle maiuscole anche quando viene passato un solo termine, quindi per verificare che i documenti trovati siano relativi a file cui nome contiene la stessa parola in qualsiasi formato.
    \item \textit{\textbf{filename: The Scie}}. Per verificare la correttezza del sistema di ranking e di ricerca, è stato controllato che, passato un termine troncato, vengano comunque trovati i file cui nome include parole "vicine" al termine cercato. Si noti che, non avendo ignorato parole comuni come "The", vengono anche riportati tanti altri documenti, ma grazie al ranking vengono valutati meno del file ricercato, cioè \textit{The Scientist.txt}
\end{itemize}
\fi

\subsection{Campo: \textit{content}}
Successivamente sono stati verificati gli stessi concetti di cui sopra (~\ref{filenameFieldQuery}) anche per il campo \textit{content}. Per cui non verranno ripetute le motivazioni per cui sono state eseguite le seguenti query, piuttosto saranno riportati solamente i risultati relativi.

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @content: "love you"@
\end{lstlisting}
\end{tabular}    
\end{center}

doc3:Ink (0.9303554)
doc82:Yellow (0.787055)
doc16:Flags (0.6891087)
doc9:X Y (0.618477)
doc37:Lovers in Japan   Reign of Love (0.5962774)
doc65:A Message (0.5756162)
doc68:Biutyful (0.49061614)

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @content: fix@
\end{lstlisting}
\end{tabular}    
\end{center}

doc39:Fix You (2.636421)
doc9:X Y (2.2264667)
doc8:Politik (1.6666911)

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @content: "Everything you want"@
\end{lstlisting}
\end{tabular}    
\end{center}

doc28:Adventure of a Lifetime (2.5110426)
doc68:Biutyful (2.1120477)

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @content: I could not stop@
\end{lstlisting}
\end{tabular}    
\end{center}

doc18:Gravity (2.7940829)
doc25:Clocks (2.7253244)
doc87:Swallowed in the Sea (2.6062596)
doc30:The Hardest Part (2.3099952)
doc12:Speed of Sound (2.1411023)
doc49:Everythings Not Lost (2.047451)
doc39:Fix You (1.5887142)
doc62:Arabesque (1.5794398)
doc16:Flags (1.5728197)
doc52:People of the Pride (1.5381694)

\begin{center}
\begin{tabular}{c}
\begin{lstlisting}[style=prompt]
    @content: want's dream@
\end{lstlisting}
\end{tabular}    
\end{center}

doc28:Adventure of a Lifetime (2.1245675)
doc11:Paradise (1.5426661)
doc66:Eko (1.5272726)
doc70:Champion of the World (1.2550737)
doc16:Flags (1.1110598)

\end{document}